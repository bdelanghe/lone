# shellcheck shell=bash
set -euo pipefail

__die() {
  echo "envrc error: $*" >&2
  exit 1
}

__require_cmd() {
  command -v "$1" >/dev/null 2>&1 || __die "missing required command: $1"
}

__require_dir() {
  local path="$1"
  local hint="$2"
  [ -d "$path" ] || __die "missing directory: $path. $hint"
}

__require_nonempty() {
  local name="$1"
  local val="${2:-}"
  local hint="$3"
  [ -n "$val" ] || __die "$name is empty. $hint"
}

__in_git_repo() {
  git rev-parse --is-inside-work-tree >/dev/null 2>&1
}

__compute_worktree_name() {
  local top
  top="$(git rev-parse --show-toplevel)"
  GIT_WORKTREE_NAME="$(basename "$top")"
  __require_nonempty GIT_WORKTREE_NAME "$GIT_WORKTREE_NAME" "Expected git top-level dir name to exist."

  # Fail-closed: require a branch name (no detached HEAD) and require it matches the worktree dir.
  GIT_BRANCH_NAME="$(git symbolic-ref --quiet --short HEAD 2>/dev/null || true)"
  __require_nonempty GIT_BRANCH_NAME "$GIT_BRANCH_NAME" "Detached HEAD is not supported; check out a branch."
  if [ "$GIT_BRANCH_NAME" != "$GIT_WORKTREE_NAME" ]; then
    __die "worktree dir ($GIT_WORKTREE_NAME) must match branch name ($GIT_BRANCH_NAME)"
  fi

  # Beads convention: claim the epic matching this worktree name.
  BD_CLAIMED_EPIC="$GIT_WORKTREE_NAME"
}

__compute_worktree_vars() {
  local git_dir git_common_dir
  git_dir="$(git rev-parse --git-dir)"
  git_common_dir="$(git rev-parse --git-common-dir)"

  if [ "$git_dir" != "$git_common_dir" ]; then
    BD_IN_GIT_WORKTREE=1

    # Prefer shared Beads store if present.
    local shared_beads main_worktree main_beads
    shared_beads="${XDG_DATA_HOME:-$HOME/.local/share}/beads/io.github/bdelanghe/lone/.beads"
    main_worktree="$(
      git worktree list --porcelain \
        | awk '$1 == "worktree" { wt = $2 } $1 == "branch" && $2 == "refs/heads/main" { print wt; exit }'
    )"
    main_beads=""
    if [ -n "$main_worktree" ]; then
      main_beads="${main_worktree}/.beads"
    fi

    if [ -d "$shared_beads" ]; then
      BEADS_DIR="$shared_beads"
    elif [ -n "$main_beads" ] && [ -d "$main_beads" ]; then
      BEADS_DIR="$main_beads"
    fi

    # In linked worktrees, force direct mode to avoid daemon branch confusion.
    BEADS_NO_DAEMON="${BEADS_NO_DAEMON:-1}"
  else
    BD_IN_GIT_WORKTREE=0
  fi

  # Resolve absolute path to git common dir for compose volume mounts.
  BARE_REPO="$(cd "$git_common_dir" && pwd -P)"
}

__compute_identity_vars() {
  if [ -z "${GIT_AUTHOR_NAME:-}" ]; then
    GIT_AUTHOR_NAME="$(git config --global --get user.name 2>/dev/null || true)"
  fi
  if [ -z "${GIT_AUTHOR_EMAIL:-}" ]; then
    GIT_AUTHOR_EMAIL="$(git config --global --get user.email 2>/dev/null || true)"
  fi

  __require_nonempty GIT_AUTHOR_NAME "${GIT_AUTHOR_NAME:-}" "Set host git user.name or export GIT_AUTHOR_NAME."
  __require_nonempty GIT_AUTHOR_EMAIL "${GIT_AUTHOR_EMAIL:-}" "Set host git user.email or export GIT_AUTHOR_EMAIL."
}

__dotenv_quote() {
  local s="$1"
  s="${s//\\/\\\\}"
  s="${s//\"/\\\"}"
  printf '"%s"' "$s"
}

__write_envfile() {
  local tmp
  tmp="$(mktemp)"
  {
    echo "# Generated by direnv (.envrc). DO NOT EDIT."
    echo "BARE_REPO=$(__dotenv_quote "${BARE_REPO:-}")"
    echo "BEADS_DIR=$(__dotenv_quote "${BEADS_DIR:-}")"
    echo "GIT_WORKTREE_NAME=$(__dotenv_quote "${GIT_WORKTREE_NAME:-}")"
    echo "GIT_BRANCH_NAME=$(__dotenv_quote "${GIT_BRANCH_NAME:-}")"
    echo "BD_CLAIMED_EPIC=$(__dotenv_quote "${BD_CLAIMED_EPIC:-}")"
    echo "BD_IN_GIT_WORKTREE=$(__dotenv_quote "${BD_IN_GIT_WORKTREE:-}")"
    echo "BEADS_NO_DAEMON=$(__dotenv_quote "${BEADS_NO_DAEMON:-}")"
    echo "GIT_AUTHOR_NAME=$(__dotenv_quote "${GIT_AUTHOR_NAME:-}")"
    echo "GIT_AUTHOR_EMAIL=$(__dotenv_quote "${GIT_AUTHOR_EMAIL:-}")"
    echo "BDUI_URL=$(__dotenv_quote "${BDUI_URL:-http://127.0.0.1:3000}")"
  } >"$tmp"

  if [ -f .env ] && cmp -s "$tmp" .env; then
    rm -f "$tmp"
  else
    mv -f "$tmp" .env
  fi
}

__configure_shell_path() {
  # Keep host PATH config out of .env (compose consumes .env and would inherit host paths).
  PATH_add scripts
  if [ -d "$HOME/.npm-global/bin" ]; then
    PATH_add "$HOME/.npm-global/bin"
  fi
}

__define_deno_stub_if_missing() {
  if command -v deno >/dev/null 2>&1; then
    return 0
  fi

  deno() {
    echo "deno is not available on the host. Run this inside the devcontainer." >&2
    echo "Hint: devcontainer exec --workspace-folder . deno <args>" >&2
    return 127
  }
}

__main() {
  __require_cmd git
  __require_cmd awk
  __require_cmd basename

  __in_git_repo || __die "not in a git worktree (required for this repo's env setup)"

  # Worktree name
  __compute_worktree_name

  # Worktree + paths
  __compute_worktree_vars
  __require_dir "$BARE_REPO" "Expected git common dir to exist."

  : "${BEADS_DIR:=${XDG_DATA_HOME:-${HOME}/.local/share}/beads/io.github/bdelanghe/lone/.beads}"
  __require_dir "$BEADS_DIR" "Create it or set BEADS_DIR before entering this directory."

  # Identity + sockets
  __compute_identity_vars

  # Write + export via dotenv (single source of truth for exports)
  __write_envfile
  dotenv .env

  # Host-only shell conveniences
  __configure_shell_path
  __define_deno_stub_if_missing
}

__main

unset -f __die __require_cmd __require_dir __require_nonempty __in_git_repo __compute_worktree_name __compute_worktree_vars __compute_identity_vars __dotenv_quote __write_envfile __configure_shell_path __define_deno_stub_if_missing __main
unset GIT_BRANCH_NAME
